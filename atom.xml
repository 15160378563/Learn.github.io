<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://qz-wzf.github.io</id>
    <title>Mr.王</title>
    <updated>2020-06-03T07:08:06.100Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://qz-wzf.github.io"/>
    <link rel="self" href="https://qz-wzf.github.io/atom.xml"/>
    <subtitle>温故而后码</subtitle>
    <logo>https://qz-wzf.github.io/images/avatar.png</logo>
    <icon>https://qz-wzf.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Mr.王</rights>
    <entry>
        <title type="html"><![CDATA[iOS中钥匙串keychain的使用]]></title>
        <id>https://qz-wzf.github.io/post/ios-zhong-yao-chi-chuan-keychain-de-shi-yong/</id>
        <link href="https://qz-wzf.github.io/post/ios-zhong-yao-chi-chuan-keychain-de-shi-yong/">
        </link>
        <updated>2020-06-03T01:50:13.000Z</updated>
        <content type="html"><![CDATA[<p>在我们日常开发中，数据如果没有接入数据库的话，大部分的数据都是存储在NSUserDefaults，这样很不安全，后面就开始慢慢的吧一些重要的数据存储在keychain当中了，也不用担心删除应用会删除之前存储的数据了。</p>
<p><strong>如何使用</strong><br>
首先导入系统框架Security.framework  然后创建KeyChain类<img src="https://qz-wzf.github.io/post-images/1591156632646.png" alt="" loading="lazy"><br>
.h实现：</p>
<pre><code class="language-#import">#import &lt;Security/Security.h&gt;

@interface KeyChain : NSObject

/**
 存数据到KeyChain钥匙串

 @param service 你自定义的一个唯一标识作为对应的数据的Key值
 @param data 要存储的数据
 */
+ (void)saveByKey:(NSString *)service Object:(id)data;

/**
 返回Key值对应得数据

 @param service 对应的Key值
 */
+ (id)loadByKey:(NSString *)service;

/**
 删除Key值对应的得数据

 @param service 对应的Key值
 */
+ (void)deleteByKey:(NSString *)service;

@end
</code></pre>
<p>.m实现</p>
<pre><code class="language-#import">
@implementation CHKeychain
+ (NSMutableDictionary *)getKeychainQuery:(NSString *)service {
  return [NSMutableDictionary dictionaryWithObjectsAndKeys:
          (id)kSecClassGenericPassword,(id)kSecClass,
          service, (id)kSecAttrService,
          service, (id)kSecAttrAccount,
          (id)kSecAttrAccessibleAfterFirstUnlock,(id)kSecAttrAccessible,
          nil];
}
//存
+ (void)saveByKey:(NSString *)service Object:(id)data {
  //得到旧数据
  NSMutableDictionary *keychainQuery = [self getKeychainQuery:service];
  //删除旧数据
  SecItemDelete((CFDictionaryRef)keychainQuery);
  //添加新对象到字典
  [keychainQuery setObject:[NSKeyedArchiver archivedDataWithRootObject:data] forKey:(id)kSecValueData];
  //添加到keychain
  SecItemAdd((CFDictionaryRef)keychainQuery, NULL);
}
//删除
+ (void)deleteByKey:(NSString *)service {
  NSMutableDictionary *keychainQuery = [self getKeychainQuery:service];
  SecItemDelete((CFDictionaryRef)keychainQuery);
}
//加载数据
+ (id)loadByKey:(NSString *)service {
  id ret = nil;
  NSMutableDictionary *keychainQuery = [self getKeychainQuery:service];
  //匹配得到数据
  [keychainQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnData];
  [keychainQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit];
  CFDataRef keyData = NULL;
  if (SecItemCopyMatching((CFDictionaryRef)keychainQuery, (CFTypeRef *)&amp;keyData) == noErr) {
      @try {
          ret = [NSKeyedUnarchiver unarchiveObjectWithData:(__bridge NSData *)keyData];
      } @catch (NSException *e) {
          NSLog(@&quot;Unarchive of %@ failed: %@&quot;, service, e);
      } @finally {
      }
  }
  if (keyData)
      CFRelease(keyData);
  return ret;
}
@end
</code></pre>
<p>除此之外，我们还可以通过配置keychain-sharing来使不同应用之间能够相互访问<br>
<img src="https://qz-wzf.github.io/post-images/1591167919348.png" alt="" loading="lazy"><br>
如图，在两个项目中配置keychain-sharing，这样就可以访问相互的keychain，以此达到数据共享。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[测试下]]></title>
        <id>https://qz-wzf.github.io/post/ce-shi-xia/</id>
        <link href="https://qz-wzf.github.io/post/ce-shi-xia/">
        </link>
        <updated>2020-06-02T02:23:03.000Z</updated>
        <content type="html"><![CDATA[<p>随便写写<br>
<img src="https://qz-wzf.github.io/post-images/1591090144117.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>